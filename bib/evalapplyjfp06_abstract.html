<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><TITLE
>Abstract : Making a fast curry: push/enter vs. eval/apply for higher-order languages</TITLE
></HEAD
><BODY BGCOLOR="#e0e0e0"
><TABLE ALIGN="center" WIDTH="800" CELLSPACING="5" BGCOLOR="#ffffff"
><TR
><TD
><P
><B
><A HREF="http://simonmar.github.io/bib/papers/evalapplyjfp06.pdf"
>Making a fast curry: push/enter vs. eval/apply for higher-order languages</A
></B
> (Simon Marlow, Simon Peyton Jones) <I
>Journal of Functional Programming</I
>, 16(4--5):415--449, July 2006</P
><P
>Higher-order languages that encourage currying are typically implemented using one of
two basic evaluation models: push/enter or eval/apply.   Implementors 
use their intuition and qualitative judgements 
to choose one model or the other.  
</P
><P
>Our goal in this paper is to provide, for the first time, a more
substantial basis for this choice, based on our qualitative and
quantitative experience of implementing both models in a
state-of-the-art compiler for Haskell.
</P
><P
>Our conclusion is simple, and contradicts our initial intuition: 
compiled implementations should use eval/apply.
</P
></TD
></TR
></TABLE
></BODY
></HTML
>
