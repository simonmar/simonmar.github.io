<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><TITLE
>Abstract : Comparing the performance of concurrent linked-list implementations in {H}askell</TITLE
></HEAD
><BODY BGCOLOR="#e0e0e0"
><TABLE ALIGN="center" WIDTH="800" CELLSPACING="5" BGCOLOR="#ffffff"
><TR
><TD
><P
><B
><A HREF="http://community.haskell.org/~simonmar/papers/concurrent-data.pdf"
>Comparing the performance of concurrent linked-list implementations in Haskell</A
></B
> (Martin Sulzmann, Edmund S. L. Lam, Simon Marlow) <I
>DAMP 2009: Workshop on Declarative Aspects of Multicore Programming</I
>, Savannah, Georgia, USA, 2009</P
><P
>Haskell has a rich set of synchronization primitives for implementing
shared-state concurrency abstractions, ranging from the very high
level (Software Transactional Memory) to the very low level (mutable
variables with atomic read-modify-write).
</P
><P
>In this paper we perform a systematic comparison of these different
concurrent programming models by using them to implement the same
abstraction: a concurrent linked-list.  Our results are somewhat
surprising: there is a full two orders of magnitude difference in
performance between the slowest and the fastest implementation.  Our
analysis of the performance results gives new insights into the
relative performance of the programming models and their
implementation.
</P
><P
>Finally, we suggest the addition of a single primitive which in our
experiments improves the performance of one of the STM-based
implementations by more than a factor of 7.
</P
></TD
></TR
></TABLE
></BODY
></HTML
>
