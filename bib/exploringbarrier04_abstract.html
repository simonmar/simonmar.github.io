<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><TITLE
>Abstract : Exploring the Barrier to Entry: Incremental Generational Garbage Collection for {H}askell</TITLE
></HEAD
><BODY BGCOLOR="#e0e0e0"
><TABLE ALIGN="center" WIDTH="800" CELLSPACING="5" BGCOLOR="#ffffff"
><TR
><TD
><P
><B
><A HREF="http://simonmar.github.io/papers/ExploringBarrierToEntry.pdf"
>Exploring the Barrier to Entry: Incremental Generational Garbage Collection for Haskell</A
></B
> (A.M. Cheadle, A.J. Field, S. Marlow, S.L. Peyton Jones, R.L. While) <I
>International Symposium on Memory Management</I
>, ACM, October 2004</P
><P
>We document the design and implementation of a &quot;production&quot;
incremental garbage collector for GHC 6.02. It builds
on our earlier work (Non-stop Haskell) that exploited GHC's
dynamic dispatch mechanism to hijack object code pointers
so that objects in to-space automatically scavenge themselves
when the mutator attempts to \enter&quot; them. This
paper details various optimisations based on code specialisation
that remove the dynamic space, and associated time,
overheads that accompanied our earlier scheme. We detail
important implementation issues and provide a detailed
evaluation of a range of design alternatives in comparison
with Non-stop Haskell and GHC's current generational collector.
We also show how the same code specialisation techniques
can be used to eliminate the write barrier in a generational
collector.
</P
></TD
></TR
></TABLE
></BODY
></HTML
>
